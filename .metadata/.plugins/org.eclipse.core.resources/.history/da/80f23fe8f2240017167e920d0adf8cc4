package com.ProjectPhh.Java;
/*
1.쓰레드란?
	프로세스는 프로그램을 수행하는 데 필요한 데이터와 메모리 등의 자원 그리고 쓰레드로 구성되어 있으며
	프로세스의 자원을 이용해서 실제로 작업을 수행하는 것이 바로 쓰레드이다.
	그래서 모든 프로세스에는 최소한 하나 이상의 쓰레드가 존재하며, 
	둘 이상의 쓰레드를 가진 프로세스를 멀티쓰레드 프로세스라고 한다.
	 
	[참고] 쓰레드를 프로세스라는 작업공간(공장)에서 작업을 처리하는 일꾼으로 생각하면 이해하기 쉽다.
	쓰레드 = 일꾼 
	 
	멀티쓰레딩은 히 나의 프로 세 스 내에 서 여러 쓰 레드가 동시 에
      작업을 수 행하는 것 이 가능 하다. 실 제 로는 한 개의 CPU가 한 번에 단 한가지 작업만 수
             행할 수 있기 때문에 이 주 짧은 시 간 동 안 여 러 작엠을 번갈 아 가며 수 행함으로써 동 시에
             여리 직 업 이 수행되 는 것처럼 보이게 히는 것 이 다 그 래서 프로세 스 의 성능 이 쓰레드의 겟수에 비례하지 않으며 ， 
             하나의 쓰레드를 가진 프로세 스 보다 두 개의 쓰레드를 가진 프로세스 가 오히려 더 낮은 성 능을 보일 수도 있다，
	
	멀티쓰레드는 여러 쓰레드가 같은 프로세스 내에서 자원을 공유 하기 때문에 
	동기 화(synchronization) , 교착상태 (deadlock)와 같은 문제들을 고려해서 신중히 프로그래밍해야 한다.		
*/

/*쓰레드의 구현과 실행*/

public class ThreadEx1 {
	public static void main(String[] args) {
		
/*
 		쓰래드 구현 방법에는 2가지가 있는데 
		Thead를 extend 하는것 ,
		Runnable 을 implements 하는 것이다.
*/
		
		
	//1. extends Thread
		Thread t1 = new ThreadEx1_1();
		
	//2. implements Runnable		
		Runnable r = new ThreadEx1_2();
		Thread t2 = new Thread(r);
		
		t1.start();
		t2.start();
	
	 //Runnable 인스페이스를 구현한 경우, Runnable인터페이스를 구현한 클래스의 인스턴스를 생성한 다음
	 //이 인스턴스를 가지고 위와 같이 Thread클래스의 인스턴스를 생성할 때 생성자의 매개변수로 제공해야 한다.
		
	}
}

class ThreadEx1_1 extends Thread {
	public void run(){
		for(int i=0 ; i < 5 ; i++ ){
			System.out.println(getName()+"  1번");
		}
	}
}	

class ThreadEx1_2 implements Runnable{
	@Override
	public void run() {
		for(int i=0 ; i < 5 ; i++ ){
			System.out.println(Thread.currentThread().getName());
			
			/*Thread클래스를 상속받으면, Thread클래스의 메서드를 직접 호출할 수 있지만,
			Runnable을 구현하면 Thread클래스의 static메서드인 Thread.currentThread().getName()를 사용해야 한다.*/
		}
	}
  }

/* 
   start()와 run() 쓰래드를 실행시킬 때 run()이 아닌 start()를 호출한다는 것에 대해서 다소 의문을 들었을 것이다. 이제
   start()와 run()에 대한 차이와 쓰레드가 실행되는 과정에 대해서 설명하고자 한다.
   
    run()을 호출하는 것은 생성된 쓰레드를 실행시키는 것이 아니라 단순히 클래스에 속한 메서드 하나를 호출 하는 것이다.
    
    반면에 start()는 새로운 쓰레드가 작업을 실행하는데 필요한 호출스택(call stack)을 생성한 다음에 run()을 호출해서,
    생성된 호출스택에 run()이 첫 번째로 저장되게 한다.
    
    모든 쓰레드는 독립적인 작업을 수행하기 위해 자신만에 호출스택을 필요로 하기 때문에, 새로운 쓰레드를 생성하고 실행시킬 때마다 
    새로운 호출스택이 생성되고 쓰레드가 종료되면 작업에 사용된 호출스택은 소멸된다.
    
   1. main메서드에서 쓰레드의 start메서드를 호출한다.
   2. start메서드는 쓰레드가 작업을 수행하는데 사용될 새로운 호출스택을 생성한다.
   3. 생성된 호출스택에 run메서드를 호출해서 쓰레드가 작업을 수행하도록 한다.
   4. 이제는 호출 스택이 2개이기 때문에 스케쥴러가 정한 순서에 의해서 번갈아 가면서 실행된다.
   
   1. main 메소드가 쓰레드의 start 메서드를 호출 한다. why? 새로운 호출 스택을 생성하기 위해
   2. 생성된 호출스택에 run 메서드를 호출해서 작업하게 한다. why? 호출스택에 run 메서드를 담기 위해
   
   우리가 쓰는 main메서드를 호출스택에 담는 역활을 하는것 또한 Thread이다. 그렇다면 왜 Thread를 선언하고 start를 사용할까?
  위 내용을 보면 알 수 있듯이 이미 하나의 호출스택을 이용하여 우리는 메소드를 실행하고 있다. 우리는 멀티쓰레드 즉 동시실행을 위해
 Thread를 선언하고 start를 사용 하는 것이다. 사실 프로그램에서 동시 실행은 없다  스케쥴러가 정한 스케쥴에 따라  이 호출스택 저 호출스택 
  번갈아 가면서 실행 될 뿐이다. 스케쥴러가 이쪽 저쪽 번갈아 가면서 실행 하기 위해서는 각각의 호출 스택 단위가 필요하다는 것을 알수 있다.
 
*/

	
